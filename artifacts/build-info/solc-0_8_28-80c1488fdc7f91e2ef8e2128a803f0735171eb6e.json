{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-80c1488fdc7f91e2ef8e2128a803f0735171eb6e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EncryptedSimpleVotingSimplified.sol": "project/contracts/EncryptedSimpleVotingSimplified.sol",
    "contracts/SimpleVoting.sol": "project/contracts/SimpleVoting.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/EncryptedSimpleVotingSimplified.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title EncryptedSimpleVotingSimplified\r\n * @dev A simplified encrypted voting contract (placeholder for FHEVM integration)\r\n * @notice This is a simplified version that demonstrates the structure without FHEVM dependencies\r\n */\r\ncontract EncryptedSimpleVotingSimplified {\r\n    enum VotingStatus {\r\n        Open,\r\n        DecryptionInProgress, \r\n        ResultsDecrypted\r\n    }\r\n    \r\n    mapping(address => bool) public hasVoted;\r\n    mapping(address => bytes32) private encryptedVotes; // Simulated encrypted votes\r\n    \r\n    VotingStatus public status;\r\n    \r\n    // Decrypted results (only available after decryption)\r\n    uint32 public decryptedYesVotes;\r\n    uint32 public decryptedNoVotes;\r\n    \r\n    uint256 public voteDeadline;\r\n    address public owner;\r\n    string public description;\r\n    \r\n    // Simulated encrypted counters (in real FHEVM, these would be euint64)\r\n    uint256 private voteCount;\r\n    \r\n    event VoteCast(address indexed voter);\r\n    event VotingCreated(string description, uint256 deadline);\r\n    event DecryptionRequested();\r\n    event ResultsDecrypted(uint32 yesVotes, uint32 noVotes);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier votingOpen() {\r\n        require(block.timestamp <= voteDeadline, \"Voting period has ended\");\r\n        require(status == VotingStatus.Open, \"Voting is not open\");\r\n        _;\r\n    }\r\n    \r\n    constructor(string memory _description, uint256 _durationInMinutes) {\r\n        owner = msg.sender;\r\n        description = _description;\r\n        voteDeadline = block.timestamp + (_durationInMinutes * 1 minutes);\r\n        status = VotingStatus.Open;\r\n        \r\n        emit VotingCreated(_description, voteDeadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Cast an encrypted vote (simplified version)\r\n     * @param encryptedSupport Simulated encrypted vote data\r\n     */\r\n    function voteEncrypted(bytes32 encryptedSupport) public votingOpen {\r\n        require(!hasVoted[msg.sender], \"Already voted\");\r\n        hasVoted[msg.sender] = true;\r\n        \r\n        // Store the encrypted vote (in real FHEVM, this would be homomorphic operations)\r\n        encryptedVotes[msg.sender] = encryptedSupport;\r\n        voteCount++;\r\n        \r\n        emit VoteCast(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev Alternative vote function for demonstration\r\n     */\r\n    function votePlaintext(bool support) public votingOpen {\r\n        require(!hasVoted[msg.sender], \"Already voted\");\r\n        hasVoted[msg.sender] = true;\r\n        \r\n        // Simulate encryption by hashing the vote with sender address\r\n        bytes32 encryptedVote = keccak256(abi.encodePacked(support, msg.sender, block.timestamp));\r\n        encryptedVotes[msg.sender] = encryptedVote;\r\n        voteCount++;\r\n        \r\n        emit VoteCast(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Request decryption of vote results (simplified)\r\n     */\r\n    function requestVoteDecryption() public {\r\n        require(block.timestamp > voteDeadline, \"Voting is not finished\");\r\n        require(status == VotingStatus.Open, \"Decryption already requested\");\r\n        \r\n        status = VotingStatus.DecryptionInProgress;\r\n        \r\n        // Simulate decryption process (in real implementation, this would be async)\r\n        _simulateDecryption();\r\n        \r\n        emit DecryptionRequested();\r\n    }\r\n    \r\n    /**\r\n     * @dev Simulate the decryption process (for demo purposes)\r\n     */\r\n    function _simulateDecryption() private {\r\n        // In a real FHEVM implementation, this would be handled by the decryption oracle\r\n        // For demonstration, we'll simulate some results\r\n        decryptedYesVotes = uint32(voteCount * 60 / 100); // Simulate 60% yes votes\r\n        decryptedNoVotes = uint32(voteCount - decryptedYesVotes);\r\n        status = VotingStatus.ResultsDecrypted;\r\n        \r\n        emit ResultsDecrypted(decryptedYesVotes, decryptedNoVotes);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the decrypted vote results\r\n     */\r\n    function getResults() public view returns (uint32, uint32) {\r\n        require(status == VotingStatus.ResultsDecrypted, \"Results were not decrypted\");\r\n        return (decryptedYesVotes, decryptedNoVotes);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if voting period is still active\r\n     */\r\n    function isVotingActive() public view returns (bool) {\r\n        return block.timestamp <= voteDeadline && status == VotingStatus.Open;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get voting information\r\n     */\r\n    function getVotingInfo() public view returns (string memory, uint256, bool, VotingStatus) {\r\n        return (description, voteDeadline, isVotingActive(), status);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get current status information\r\n     */\r\n    function getStatus() public view returns (VotingStatus, bool, bool, uint256) {\r\n        bool votingEnded = block.timestamp > voteDeadline;\r\n        bool canRequestDecryption = votingEnded && status == VotingStatus.Open;\r\n        return (status, votingEnded, canRequestDecryption, voteCount);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get vote count (for demo purposes)\r\n     */\r\n    function getVoteCount() public view returns (uint256) {\r\n        return voteCount;\r\n    }\r\n}"
      },
      "project/contracts/SimpleVoting.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SimpleVoting\r\n * @dev A basic voting contract without encryption (for comparison)\r\n */\r\ncontract SimpleVoting {\r\n    mapping(address => bool) public hasVoted;\r\n    uint32 public yesVotes;  // Reduced from uint64 to save gas\r\n    uint32 public noVotes;   // Reduced from uint64 to save gas\r\n    uint32 public voteDeadline; // Reduced from uint256, enough until 2106\r\n    address public owner;\r\n    string public description;\r\n    \r\n    event VoteCast(address indexed voter, bool support);\r\n    event VotingCreated(string description, uint256 deadline);\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier votingOpen() {\r\n        require(block.timestamp <= voteDeadline, \"Voting period has ended\");\r\n        _;\r\n    }\r\n    \r\n    constructor(string memory _description, uint256 _durationInMinutes) {\r\n        owner = msg.sender;\r\n        description = _description;\r\n        voteDeadline = uint32(block.timestamp + (_durationInMinutes * 1 minutes));\r\n        \r\n        emit VotingCreated(_description, voteDeadline);\r\n    }\r\n\r\n    /**\r\n     * @dev Cast a vote\r\n     * @param support true for yes, false for no\r\n     */\r\n    function vote(bool support) public votingOpen {\r\n        require(!hasVoted[msg.sender], \"Already voted\");\r\n        hasVoted[msg.sender] = true;\r\n\r\n        if (support) {\r\n            yesVotes += 1;\r\n        } else {\r\n            noVotes += 1;\r\n        }\r\n        \r\n        emit VoteCast(msg.sender, support);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the current vote results\r\n     * @return yes count and no count\r\n     */\r\n    function getResults() public view returns (uint32, uint32) {\r\n        return (yesVotes, noVotes);\r\n    }\r\n    \r\n    /**\r\n     * @dev Check if voting period is still active\r\n     */\r\n    function isVotingActive() public view returns (bool) {\r\n        return block.timestamp <= voteDeadline;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get voting information\r\n     */\r\n    function getVotingInfo() public view returns (string memory, uint256, bool) {\r\n        return (description, voteDeadline, isVotingActive());\r\n    }\r\n}"
      }
    }
  }
}